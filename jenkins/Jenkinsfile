pipeline {
    agent any

    environment {
        AWS_REGION = 'us-east-1'
        ECR_REGISTRY = credentials('aws-ecr-registry')
        EKS_CLUSTER_NAME = 'eks-cicd-dev-eks'
        IMAGE_NAME = 'eks-cicd-dev-app'
        DOCKER_IMAGE = "${ECR_REGISTRY}/${IMAGE_NAME}"
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timestamps()
        timeout(time: 30, unit: 'MINUTES')
        disableConcurrentBuilds()
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    env.GIT_COMMIT_SHORT = sh(
                        script: "git rev-parse --short HEAD",
                        returnStdout: true
                    ).trim()
                    env.IMAGE_TAG = "${env.BUILD_NUMBER}-${env.GIT_COMMIT_SHORT}"
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                dir('app') {
                    sh """
                        docker build \
                            --build-arg BUILD_DATE=\$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
                            --build-arg VERSION=${IMAGE_TAG} \
                            --build-arg VCS_REF=${GIT_COMMIT_SHORT} \
                            -t ${IMAGE_NAME}:${IMAGE_TAG} \
                            -t ${IMAGE_NAME}:latest \
                            .
                    """
                }
            }
        }

        stage('Run Unit Tests') {
            steps {
                dir('app') {
                    sh """
                        docker run --rm ${IMAGE_NAME}:${IMAGE_TAG} python -m pytest tests/ -v --junitxml=test-results.xml || true
                    """
                }
            }
            post {
                always {
                    junit allowEmptyResults: true, testResults: 'app/test-results.xml'
                }
            }
        }

        stage('Security Scan - Trivy') {
            steps {
                sh """
                    trivy image \
                        --severity HIGH,CRITICAL \
                        --exit-code 0 \
                        --format table \
                        ${IMAGE_NAME}:${IMAGE_TAG}
                """
                sh """
                    trivy image \
                        --severity HIGH,CRITICAL \
                        --format json \
                        -o trivy-report.json \
                        ${IMAGE_NAME}:${IMAGE_TAG}
                """
            }
            post {
                always {
                    archiveArtifacts artifacts: 'trivy-report.json', allowEmptyArchive: true
                }
            }
        }

        stage('Push to ECR') {
            steps {
                withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', 
                    credentialsId: 'aws-credentials']]) {
                    sh """
                        aws ecr get-login-password --region ${AWS_REGION} | \
                        docker login --username AWS --password-stdin ${ECR_REGISTRY}

                        docker tag ${IMAGE_NAME}:${IMAGE_TAG} ${DOCKER_IMAGE}:${IMAGE_TAG}
                        docker tag ${IMAGE_NAME}:latest ${DOCKER_IMAGE}:latest

                        docker push ${DOCKER_IMAGE}:${IMAGE_TAG}
                        docker push ${DOCKER_IMAGE}:latest
                    """
                }
            }
        }

        stage('Deploy to Dev') {
            when {
                branch 'develop'
            }
            steps {
                withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', 
                    credentialsId: 'aws-credentials']]) {
                    sh """
                        aws eks update-kubeconfig --name ${EKS_CLUSTER_NAME} --region ${AWS_REGION}

                        # Update image in deployment
                        cd kubernetes/overlays/dev
                        kustomize edit set image APP_IMAGE_PLACEHOLDER=${DOCKER_IMAGE}:${IMAGE_TAG}
                        
                        # Apply manifests
                        kubectl apply -k .

                        # Wait for rollout
                        kubectl rollout status deployment/dev-app -n app-dev --timeout=300s
                    """
                }
            }
        }

        stage('Deploy to Production') {
            when {
                branch 'main'
            }
            steps {
                input message: 'Deploy to Production?', ok: 'Deploy'
                
                withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', 
                    credentialsId: 'aws-credentials']]) {
                    sh """
                        aws eks update-kubeconfig --name ${EKS_CLUSTER_NAME} --region ${AWS_REGION}

                        # Update image in deployment
                        cd kubernetes/overlays/prod
                        kustomize edit set image APP_IMAGE_PLACEHOLDER=${DOCKER_IMAGE}:${IMAGE_TAG}
                        
                        # Apply manifests
                        kubectl apply -k .

                        # Wait for rollout
                        kubectl rollout status deployment/prod-app -n app-prod --timeout=300s
                    """
                }
            }
        }
    }

    post {
        always {
            cleanWs()
            sh "docker rmi ${IMAGE_NAME}:${IMAGE_TAG} || true"
            sh "docker rmi ${IMAGE_NAME}:latest || true"
            sh "docker rmi ${DOCKER_IMAGE}:${IMAGE_TAG} || true"
            sh "docker rmi ${DOCKER_IMAGE}:latest || true"
        }
        success {
            echo "Pipeline completed successfully!"
            // Uncomment to add Slack notification
            // slackSend(color: 'good', message: "Build Successful: ${env.JOB_NAME} #${env.BUILD_NUMBER}")
        }
        failure {
            echo "Pipeline failed!"
            // Uncomment to add Slack notification
            // slackSend(color: 'danger', message: "Build Failed: ${env.JOB_NAME} #${env.BUILD_NUMBER}")
        }
    }
}
